---
title: "Metabolomics Process And Plot"
output: html_notebook
---

```{r}
source("../config.R") #Loads libraries, variables and global function
```




#### Define global and user-specific variables
1. Define your own paths and variables
2. R Detects your Microsoft / Apple/ Linux username (could result in conflicts with same name)
3. Assign your own variables to global variables
```{r}

export_filename = paste("Metabolomics_", DOI)
date = format(Sys.time(), " %Y-%m-%d") 
control <- toupper(risk_constellation)


####### Create folders
dir.create(file.path(project_path, "/Metabolomics"), showWarnings = FALSE)

```

#### 1. Import covariates and diagnosis
```{r}
#### Covariates

#prepare vector for reading out correct covariate columns (once done and added to fread function in import section, this has no longer to be run until new covariates come in)
#covariate_string <- cat(covariate_index$datafield2, sep="", file="covariate_index.txt") #erstellt .txt datei im Working directory. Diese kann kopiert werden und in die fread-Funktion nach der eid eingefügt werden

#Extract covariates of interest
# setwd(sharepoint_ukb)
# covariates<- fread("raw/ukb52200.csv", select=c("eid", '21000-0.0','21001-0.0','48-0.0','21002-0.0','50-0.0','21003-0.0','31-0.0','20116-0.0','20160-0.0','20161-0.0','20117-0.0','1558-0.0','3731-0.0','4407-0.0','4418-0.0','4429-0.0','4440-0.0','4451-0.0','4462-0.0','1568-0.0','1578-0.0','1588-0.0','1598-0.0','1608-0.0','5364-0.0','1618-0.0','1628-0.0','2664-0.0','10818-0.0','3859-0.0','10853-0.0','4080-0.0','4080-0.1','6153-0.0','6177-0.0','90087-0.0','20107-0.0','20110-0.0','20111-0.0','2443-0.0','26410-0.0','26427-0.0','26426-0.0','22009-0.1','22009-0.2','22009-0.3','22009-0.4','22009-0.5'))
# write.csv(covariates, file="extracted/covariates.csv", row.names=FALSE)

setwd(sharepoint_ukb)
df_withdrawals <- read.delim("raw/withdrawals.txt")
covariates <- fread("extracted/covariates.csv") %>% check_and_remove_withdrawals(df_withdrawals)
covariate_index <- read_excel(master_table, sheet = "All covariates")   # import index data (Liste mit allen covariates, codes, units etc)
covariates <-  setnames(covariates, old = covariate_index$datafield1, new = covariate_index$Assessment, skip_absent=TRUE) #rename variables after index
covariates_subset <- covariates %>%
  select("eid", "Ethnicity", "BMI", "AGE", "SEX", "PC1", "PC2", "PC3", "PC4", "PC5")              #only covariates of interest
setwd(project_path)
load("data/dataframes/df_icd.RData") 
load("data/dataframes/df_par_5_years.RData")
df_icd <-df_icd %>% check_and_remove_withdrawals(df_withdrawals)
sapply(df_icd, class)
```


#### 2. Import and process Table Y (Information (Diagnosis, Factor etc. to be correlated)) (can also be taken from df_icd above)
Format has to be 

|--eid--|--DOI--|

after following markdown segment, with DOI containing 0 and 1 information for the diagnosis of interest
```{r}
#Import information that contains 0 - control group (matches) and 1 (phenotype/diagnosis of interest) from PPSM (1) or directly from UKB (Extrahiere_Diagnosen): Two columns, eid and DOI


# To switch between options, mark all the rows you want to run and press Strg + Shift + C


      # Option A1: from matching / big group / subgroup (Table Y Extract)
      setwd(project_path)
      df_y <- read.csv(paste(project_path, "/data/dataframes/df_y.csv", sep='')) %>% check_and_remove_withdrawals(df_withdrawals)
      df_doi<-select(df_y, c(eid, status)) %>% #Change HCC to diagnosis of your choice
        rename(c("DOI" = "status"))

      df_doi <- inner_join(df_doi, par_eids, by="eid") #Subset your desired subset (defined previously in Extract multiple diagnosis)
      rm(df_y)
      

      #Option A2: from matching/subgroup
      #setwd(home)
      #df_ppsm <- fread("Patient_tables/Cirrhosis_Subgroup_HCC.csv")
      #df_y <- read.csv(paste(project, "/data/dataframes/df_y.csv", sep=''))
      #df_doi<-select(df_y, c(eid, HCC)) %>% #Change HCC to diagnosis of your choice
        #rename(c("DOI" = "HCC"))
      
      #df_doi <- read.csv("HCC/Pat_with_HCC_C220_and_controls.csv")
      

      # #Option B: without matching, continuous variable -> gets transformed in high and low group
      # setwd("C:/Users/Jan/OneDrive/Dokumente/PostDoc/Patient_tables") 
      # df_doi <- fread("VitaminE.csv") 
      # 
      # median <- median(df_cont$VitaminE)
      # df_doi$DOI[df_cont$VitaminE > median] <- 1
      # df_doi$DOI[df_cont$VitaminE < median] <- 0
      # 
      # df_doi<-select(df_doi, c(eid, DOI))
      
      # #Option C: using only upper and lower quartile
      # setwd("C:/Users/Jan/OneDrive/Dokumente/PostDoc/Patient_tables") 
      # df_doi <- fread("VitaminE.csv")                                             #Changes these according to your DOI
      # df_doi$quartile <- ntile(df_doi$VitaminE, 4)                                #Changes these according to your DOI
      # df_doi$DOI[df_doi$quartile == 4] <- 1
      # df_doi$DOI[df_doi$quartile == 1] <- 0
      # df_doi$DOI[df_doi$quartile == 3] <- NA
      # df_doi$DOI[df_doi$quartile == 2] <- NA
      # df_doi <- df_doi[complete.cases(df_doi)]
      
      
      #Option D (Missing): Directly for continuous variable
      
      #Quality control
      print(paste("Amount of positive cases in imported df:", sum(df_doi$DOI, na.rm = TRUE)))

```




#### 3. Preprocessing metabolomics
```{r}
#prepare vector for reading out correct metabolite columns (once done and added to fread function, this has no longer to be run until new metabolites come in)
      #NMR_Metabolomics_Index <- read_excel("~/PostDoc/Results/Metabolomics/NMR Metabolomics Index.xlsx")
      #NMR_Metabolomics_Index$datafield <- paste0('"', NMR_Metabolomics_Index$datafield, '-0.0",')
      #nmrstring <- cat(NMR_Metabolomics_Index$datafield, sep="", file="metabolomics_index.txt")

#extract metabolite information of all UKB Patients into df (cat Funktion oben erstellt .txt Datei im working directory, muss in fread-Funktion eingefügt werden, CAVE Komma am Ende entfernen)
      #  setwd(sharepoint_ukb)
      #  library(data.table)
      # df_metabolomics<- fread("raw/ukb674682.csv", select=c("eid", "23474-0.0","23475-0.0","23476-0.0","23477-0.0","23460-0.0","23479-0.0","23440-0.0","23439-0.0","23441-0.0","23433-0.0","23432-0.0","23431-0.0","23484-0.0","23526-0.0","23561-0.0","23533-0.0","23498-0.0","23568-0.0","23540-0.0","23505-0.0","23575-0.0","23547-0.0","23512-0.0","23554-0.0","23491-0.0","23519-0.0","23580-0.0","23610-0.0","23635-0.0","23615-0.0","23590-0.0","23640-0.0","23620-0.0","23595-0.0","23645-0.0","23625-0.0","23600-0.0","23630-0.0","23585-0.0","23605-0.0","23485-0.0","23418-0.0","23527-0.0","23417-0.0","23562-0.0","23534-0.0","23499-0.0","23569-0.0","23541-0.0","23506-0.0","23576-0.0","23548-0.0","23513-0.0","23416-0.0","23555-0.0","23492-0.0","23520-0.0","23581-0.0","23611-0.0","23636-0.0","23616-0.0","23591-0.0","23641-0.0","23621-0.0","23596-0.0","23646-0.0","23626-0.0","23601-0.0","23631-0.0","23586-0.0","23606-0.0","23473-0.0","23404-0.0","23481-0.0","23430-0.0","23523-0.0","23429-0.0","23558-0.0","23530-0.0","23495-0.0","23565-0.0","23537-0.0","23502-0.0","23572-0.0","23544-0.0","23509-0.0","23428-0.0","23551-0.0","23488-0.0","23516-0.0","23478-0.0","23443-0.0","23450-0.0","23457-0.0","23486-0.0","23422-0.0","23528-0.0","23421-0.0","23563-0.0","23535-0.0","23500-0.0","23570-0.0","23542-0.0","23507-0.0","23577-0.0","23549-0.0","23514-0.0","23420-0.0","23556-0.0","23493-0.0","23521-0.0","23582-0.0","23612-0.0","23637-0.0","23617-0.0","23592-0.0","23642-0.0","23622-0.0","23597-0.0","23647-0.0","23627-0.0","23602-0.0","23632-0.0","23587-0.0","23607-0.0","23470-0.0","23461-0.0","23462-0.0","23480-0.0","23406-0.0","23463-0.0","23465-0.0","23405-0.0","23471-0.0","23466-0.0","23449-0.0","23456-0.0","23447-0.0","23454-0.0","23444-0.0","23451-0.0","23445-0.0","23459-0.0","23452-0.0","23468-0.0","23437-0.0","23434-0.0","23483-0.0","23414-0.0","23525-0.0","23413-0.0","23560-0.0","23532-0.0","23497-0.0","23567-0.0","23539-0.0","23504-0.0","23574-0.0","23546-0.0","23511-0.0","23412-0.0","23553-0.0","23490-0.0","23518-0.0","23579-0.0","23609-0.0","23634-0.0","23614-0.0","23589-0.0","23639-0.0","23619-0.0","23594-0.0","23644-0.0","23624-0.0","23599-0.0","23629-0.0","23584-0.0","23604-0.0","23446-0.0","23458-0.0","23453-0.0","23472-0.0","23402-0.0","23448-0.0","23455-0.0","23438-0.0","23400-0.0","23401-0.0","23436-0.0","23464-0.0","23427-0.0","23415-0.0","23442-0.0","23419-0.0","23482-0.0","23426-0.0","23524-0.0","23425-0.0","23559-0.0","23531-0.0","23496-0.0","23423-0.0","23566-0.0","23538-0.0","23503-0.0","23573-0.0","23545-0.0","23510-0.0","23424-0.0","23552-0.0","23489-0.0","23517-0.0","23411-0.0","23407-0.0","23487-0.0","23410-0.0","23529-0.0","23409-0.0","23564-0.0","23536-0.0","23501-0.0","23571-0.0","23543-0.0","23508-0.0","23578-0.0","23550-0.0","23515-0.0","23408-0.0","23557-0.0","23494-0.0","23522-0.0","23435-0.0","23583-0.0","23613-0.0","23638-0.0","23618-0.0","23593-0.0","23643-0.0","23623-0.0","23598-0.0","23648-0.0","23628-0.0","23603-0.0","23633-0.0","23588-0.0","23608-0.0","23469-0.0","23403-0.0","23467-0.0"))
      

#write.csv(df_metabolomics, file= paste(sharepoint_ukb, "/extracted/metabolomics250k.csv", sep = ""))    #export raw table
setwd(sharepoint_ukb)             #Import from here once a csv with the extracted metabolomics is on your harddrive
metabolomics_index <- read_excel(master_table, sheet = "NMR_Metabolomics") #read index data
df_metabolomics <- fread("extracted/metabolomics250k.csv") %>% check_and_remove_withdrawals(df_withdrawals) %>% na.omit() #read dataframe 

df_metabolomics <- na.omit(df_metabolomics) # Select non-Na participants only  
print(paste("Number of participants still included:", nrow(df_metabolomics))) #correlates to number of participants still included (should be 248286 (previously 106804)
df_metabolomics$V1 <- NULL #Remove unnecessary v1 column

#MinMax normalization             
print("Summary of first 5 metabolites before normalization")
summary(df_metabolomics[,1:5])
colnames <- colnames(df_metabolomics)
df_metabolomics[,2:ncol(df_metabolomics)] <- as.data.frame(lapply(df_metabolomics[,2:ncol(df_metabolomics)], minmax))
colnames(df_metabolomics) <- colnames

#Set names of metabolites
df_metabolomics <-  setnames(df_metabolomics, old = metabolomics_index$datafield1, new = metabolomics_index$name_ukb, skip_absent=TRUE)

#sanity(df_metabolomics)
print("Summary of first 5 metabolites after normalization and applying actual names")
summary(df_metabolomics[,1:5])

#Order the columns
col_order <- match(metabolomics_index$name_ukb, colnames(df_metabolomics))
col_order <- c(1, col_order)
df_metabolomics <- as.data.frame(df_metabolomics)
df_metabolomics <- df_metabolomics[,col_order]

#Subset for directly measured metabolites (the other ones are quotients which you are less likely to need)
df_metabolomics <- subset(df_metabolomics[1:144])
# na_summary <- sapply(df_metabolomics, function(x) sum(is.na(x)))
# print(na_summary)


#write.csv(df_metabolomics, file= paste(sharepoint_ukb, "/processed/metabolomics250k.csv", sep = ""))  
```

Subset the rows for only patients with your desired subset (e.g. chronic liver disease) (new option see above)
```{r}
# #Put your control diagnoses in here (column names from the Meta Table that you want)
# ################################# 
# 
# 
# setwd(sharepoint_ukb)
# btd <- read_excel(master_table, sheet= "ICD_Singles") #biliary tract disease
# group_btd <- "Biliary Tract diseases"
# btd <- btd$Diagnosis[btd$Group==group_btd]
# 
# cld  <- read_excel(master_table, sheet= "ICD_Liver") ##### change this to import all from ICD_Liver 
# group_cld <- "Chronic Liver disease" 
# cld_diags <- c("SLD", "Cirrhosis", "Viral Hepatitis")
# cld <- cld[cld$Group %in% cld_diags, ]
# cld <- cld$Diagnosis
# 
# cca <- read_excel(master_table, sheet= "ICD_Singles")
# group_cca <- "Hepatobiliary cancer"
# cca <- cca$Diagnosis[cca$Group == group_cca]
# 
# hcc <- c("Liver cancer, HCC", "Liver cancer, unspecified")
# 
# cholelithiasis <- c("Cholelithiasis")
# 
# if (DOI == "CCa") {
#   vec_risk_constellation <- c(cld, btd, cholelithiasis)
# } else if (DOI == "HCC") {
#   vec_risk_constellation <- cld
# }
# subset_patients_at_risk <- function(df_icd, vec_risk_constellation, na.rm = TRUE) { #Function for subsetting
#   control_diag <- intersect(colnames(df_icd), vec_risk_constellation)
#   status <- rowSums(df_icd[, ..control_diag, drop = FALSE]) > 0
#   print(paste("Rows with desired diagnosis in df_icd:" , sum(status)))
#   df_status <- data.frame(eid=df_icd$eid, status = status)
#   merged_data <- merge(df_metabolomics, df_status, by = "eid")
#   df_patients_at_risk <- merged_data[merged_data$status == TRUE, ] %>% data.frame %>%
#     select(-status)
#   # subset_control_data <- data.frame(subset_control_data)
#   print(paste("Rows with desired diagnosis and available metabolomics:", nrow(df_patients_at_risk)))
# return(df_patients_at_risk)
# }
# 
# df_metabolomics <- subset_patients_at_risk(df_icd, vec_risk_constellation)

```





####  Old Code Snippets
```{r}
# subset_controls <- function(na.rm = TRUE, control_diag, df_icd, vec_risk_constellation) {
#   control_diag <- intersect(colnames(df_icd), vec_risk_constellation)
#   status <- rowSums(df_icd[, ..control_diag, drop = FALSE]) > 0
#   df_status <- data.frame(eid=df_icd$eid, status = status)
#   merged_data <- merge(df_metabolomics, df_status, by = "eid")
#   subset_control_data <- merged_data[merged_data$status == TRUE, ]
#   subset_control_data <- data.frame(subset_control_data)
# return(subset_control_data)
##############################
#row_subset= "all"  #or "all" 
##############################
# subset_controls <- function(na.rm = TRUE, control_diag, df_icd, control_vec) {
#   control_diag <- intersect(colnames(df_icd), control_vec)
#   status <- rowSums(df_icd[, ..control_diag, drop = FALSE]) > 0
#   df_status <- data.frame(eid=df_icd$eid, status = status)
#   merged_data <- merge(df_metabolomics, df_status, by = "eid")
#   subset_control_data <- merged_data[merged_data$status == TRUE, ]
#   print(paste("Amount of included participants with metabolomics after subsetting:", nrow(df_metabolomics))) #Quality control
# return(subset_control_data)
#   
#   
# }
# vec_risk_constellation <- c("cld", "btd", "ced", "cholelithiasis")
# btd <- c("Biliary Tract diseases")
# cholelithiasis <- c("Cholelithiasis")
# df_icd_cols <- colnames(df_icd)

# exclude_cols <- c("eid", "Colorectal cancer", "Arterial hypertension", "Esophageal cancer",
#                 "Gastric cancer", "Pancreatic cancer", "Small intestine cancer", "DM", "Hepatobiliary cancer")
# 
# 
 #cld <- setdiff(colnames(df_icd), exclude_cols)
 # cld_status <- rowSums(df_icd[, ..cld, drop = FALSE]) > 0 # Calculate cld status for each row
 # df_cld_status <- data.frame(eid = df_icd$eid, cld_status = cld_status)
 # df_metabolomics <- merge(df_metabolomics, df_cld_status, by = "eid") #append cld status
 #  df_metabolomics <- df_metabolomics[df_metabolomics$cld_status == TRUE, ] # Subset the merged dataframe for rows with cld_status = TRUE
 #   print(paste("Amount of included participants with metabolomics after subsetting:", nrow(df_metabolomics))) #Quality control

```




#### 3b Merging tables with metabolomics to table with actual outcome (DOI) and controls
```{r}
#perform inner join
      df_norm_met<-merge(df_metabolomics, df_doi , by.x = "eid", by.y = "eid")
      print(paste("Amount of", DOI, "in Metabolomics dataframe:", sum(df_norm_met$DOI, na.rm = TRUE)))
      print(paste("Amount of", control, "(controls) in Metabolomics dataframe:", sum(df_norm_met$DOI == 0, na.rm = TRUE)))
      df_norm_met<-as.data.frame(df_norm_met)

#merge covariate data of interest and diagnosis to df for correcting on age, sex, bmi, diabetes etc.
      df_norm_met<-merge(df_norm_met, covariates_subset , by.x = "eid", by.y = "eid", all.x=TRUE)
      df_norm_met<-merge(df_norm_met, df_icd , by.x = "eid", by.y = "eid", all.x=TRUE)
```



#### 4. Linear model

```{r}
#We analyzed 249 parameters measured by NMR. To do so, we created a dataset that includes the 249 metabolites as well as age, BMI, sex, ethnicity and HCCstatus. 
summary_table <- function(x) {
  
  # Capture number of columns passed to the function
  num_vars <- ncol(x)
  
  # Pre-define lists that will be populated and then collapsed by rest of function
  models <- vector("list", length = num_vars)
  first_tables <- vector("list", length = num_vars)
  second_tables <- vector("list", length = num_vars)
  
  # Loop to create each row for the final table (Add other covariates here ( AGE + SEX + BMI))
  for (i in 1:num_vars) {
    
    #models[[i]] <- lm(x[[i]] ~ HCC + AGE + SEX + BMI + Other.and.unspecified.cirrhosis.of.liver, data = df_norm_met)                     #Controlling for Liver cirrhosis
     models[[i]] <- lm(x[[i]] ~ DOI + AGE + SEX + BMI, data = df_norm_met)
    first_tables[[i]] <- broom::tidy(models[[i]])
  } 
  
  # Combine the rows together into a final table
  final_table <- do.call("rbind", first_tables)
  
  return(final_table)
}
#In Klammer einfügen: [1.Zu untersuchender Parameter: Letzter Metabolit (= vorletzte Spalte) ], term anpassen zu Diagnosis of interest
final_table1 <- summary_table(df_norm_met[2:144])
final_table_DOI <- subset(final_table1, term=="DOI")
final_table_DOI$log <- -(log10(final_table_DOI$p.value))
final_table_DOI<-final_table_DOI[-c(1,2,3,4,5)]  
```



#### 5a. Volcano Plot
```{r}
#a: For Volcano Plot: In Klammer einfügen: [1.EID: Letzter Metabolit (= vorletzte Spalte) ]
#         newtable<- aggregate(df[, 1:250], list(df$DOI), mean, na.rm=TRUE)
#         newtable[3,]=c(3,newtable[2,-1]/newtable[1,-1])
#         newtable[4,]=log2(newtable[3,])
# 
# newtable<-newtable[-c(1,2)]
# table<-as.data.frame(t(as.data.frame(newtable)))
# table<-table[-c(1,2,3)]
# table<-as.data.frame(table)
# 
#         all_DOI<-cbind(table, final_table)
#         # Write the final table to your working directory as a xlsx, copy columns 4 and log (without header) to volcano plot example
#         setwd("~/PostDoc/Results/Metabolomics")
#         NMR_Metabolomics_Index <- read_excel("NMR Metabolomics Index.xlsx")
#         all_DOI$metabolite <- NMR_Metabolomics_Index$metabolite
        
        # ggf ergänzen von Code zum sortieren der metabolite in Gruppen 
        #write.xlsx(all_DOI, file=paste(path, export_filename, "_volcano", date, ".xlsx", sep=""), col.names=TRUE, row.names=TRUE, append=FALSE)
```



#### 5b: Preparation for Circle Plot
```{r}
### b: for circle Plot: Ziel = Tabelle mit id_name_s ; text1 (=Metabolit); Estimate; StdErr; WaldChiSq
        # select required columns, format column labels according to circle plot
circleplot_index <- metabolomics_index[1:143, ] #we only want the "real values", not quotients
        table_circleplot <- subset(final_table1, term=="DOI")
        table_circleplot$text1 <- circleplot_index$name_ukb
        table_circleplot<-as.data.frame(table_circleplot)
        table_circleplot <- cbind(id_name_s = rownames(table_circleplot), table_circleplot)
        table_circleplot <- subset(table_circleplot, select = c(text1, estimate, std.error, p.value))
        table_circleplot <- rename(table_circleplot, c("Estimate" = "estimate"))
        table_circleplot <- rename(table_circleplot, c("StdErr" = "std.error"))
        
        
        #sort by NMR_Metabolomics_Circle_Plot_Index Tabelle (143 selektierte Metabolite)
        table_circleplot_indexed <- merge(table_circleplot, metabolomics_index , by.x = "text1", by.y = "name_ukb")
        table_circleplot_indexed <- arrange(table_circleplot_indexed, id_name_s)
        #auswählen von erforderlichen Spalten für Circle Plot
        table_circleplot_final <- subset(table_circleplot_indexed, select = c(id_name_s, text1, Estimate, StdErr, p.value))
        
        #export dataframe to csv (further use in circle plot) and xlsx (for reproducibility/control purposes)

        
        write.xlsx(table_circleplot_final, file= paste(project_path,"/Metabolomics/", export_filename,date, ".xlsx", sep = ""))
        write.csv(table_circleplot_final, file= paste(project_path, "/Metabolomics/", export_filename, date, ".csv", sep = ""))

```


#### 6: Circle plot
```{r}
##################################################### 1. Preparing to call data ######################################
path <- paste(project_path, "/visuals/", sep="")
date_out = format(Sys.time(), " %Y-%m-%d")        
file.out <- paste("Metabolomics ", DOI, " vs ", control, sep="")  #file.out = Substring for the output file name.
fact <- "mets"                                      #fact = String that can be changed. I randomly chose “mets”.


#################################################### 2. Import datasets ################################################

#Using the objects define above, we now call the datasource with SAS output to create datasub.

#We exponentiate Estimate to create RR.
#We then create RR_1<-RR if RR< 1 (i.e. those with negative associations), else RR_1<-1.
#We also then create RR_2<-RR if RR>1 (i.e. those with positive associations), else RR_2<-1.

datasub <<- table_circleplot_final 

# 1.
datasub$RR <- exp(datasub$Estimate)

# 2.
datasub$RR_1 <- datasub$RR
datasub$RR_1[datasub$RR>1] <- 1

# 3.
datasub$RR_2 <- datasub$RR
datasub$RR_2[datasub$RR<1] <- 1


#########################################  3. Adjusting p-values #############################################

# 1. From SAS output now imported into datasub, estimate p-values from chisq statistics datasub$RawP.
# 2. Using the false discovery rate adjustment by Benjamini & Hochberg, p.adjust estimates adjusted p-values datasub$AdjP.
# 3. Then, adds flags for the metabolites with evidence against the null hypothesis bellow the fdr-adjusted “significance level”.
# 4. We then create new vectors for estimates that are significant (suffix = _s). 
#    NB, suffix _1 is used for estimates with negative associations and suffix _2 for estimates 
#    with positive associations. We will add colours later (red for positive and blue for negative, darker shade for those below the significance threshold).
# 5. If flagged as “non-significant” then newly created vectors are transformed into 1 (the value for the null hypothesis).
# 6. If flagged as “significant” then original vectors are transformed into 1 (the value for the null hypothesis).
# 7. Estimates the number of metabolites based on de dimension of the dataset, necessary later.

#1. (datasub$RawP <- pchisq(datasub$WaldChiSq, 1, lower.tail=FALSE)) -> Only necessary when input != p-value but WaldChiSquare (for categorical variables)

#2.
datasub$AdjP <- p.adjust(datasub$p.value, method = "bonferroni")

# 3.
datasub$Sig<-NA
datasub$Sig[datasub$AdjP< 0.05] <- 1
datasub$Sig[datasub$AdjP>= 0.05] <- 0

# 4. 
datasub$RR_1_s <- datasub$RR_1
datasub$RR_2_s <- datasub$RR_2

# 5. 
datasub$RR_1_s[datasub$Sig==0] <- 1
datasub$RR_2_s[datasub$Sig==0] <- 1

# 6.
datasub$RR_1[datasub$Sig==1] <- 1
datasub$RR_2[datasub$Sig==1] <- 1

# 7.
len.data <<-  as.numeric(dim(datasub)[1])




########################################  4. Plotting parameters ###########################################################

# In this section we input the parameters for the plotting areas and steps are taken to keep proportions. Importantly, the measures to keep proportionality could be substantially improved.

#### Y-axis ####

# 1. YLIM YCUTS and YCUTS.LABS define the Y-axis. Parameters here are defined manually but could be automated by extracting MIN and MAX 
#    and using the pretty function to define cuts and labels.
# 2. Alternatively, one could define labels as percentage instead of relative risks, if desired.
# 3. ylab 1:3 define the levels for labels around the circular plot that are relative and proportional to the MAX and MIN of the axis.
# 4. If estimate is off limits from YLIM then estimates are trimmed. Currently, the plot doesn’t flag this transformation, 
#    although it should be evident as the bar ends precisely at the limit of the axis and user should be aware as the axis limits are currently defined manually.

#Log_scale <- read_excel("C:/Users/Jan/OneDrive/Dokumente/PostDoc/Figures/Circle Plots/Log scale.xlsx")

# Alternativ: 0.6, 1.7 cuts= 0.6, 0.75, 1, 1.3, 1.7
YLIM <- c(log(0.9), log(1.1))
YCUTS <- c(log(0.9), log(0.95), log(1), log(1.05), log(1.1))
YCUTS.LABS <- as.character(exp(YCUTS))
YMAX <- exp(max(YLIM))
YMIN <- exp(min(YLIM))

#"zooming out"
#YLIM <- c(log(0.4), log(2.4))
#YCUTS <- c(log(0.4), log(0.6), log(1), log(1.67), log(2.4))
#YCUTS.LABS <- as.character(exp(YCUTS))
#YMAX <- exp(max(YLIM))
#YMIN <- exp(min(YLIM))

# 2.
#YCUTS.LABS <- c("-40%", "-20%", "0%", "30%", "60%")
#Change the parameters for varying y-position of labels (ylab3 = outer, 2 = medium (LDL etc), 1 = XXl, XL etc)
# 3.
ylab0 <- exp(log(YMAX)+log(YMAX)*0.1)
ylab1 <- exp(log(YMAX)+log(YMAX)*0.2)
ylab2 <- exp(log(YMAX)+log(YMAX)*0.7)
ylab3 <- exp(log(YMAX)+log(YMAX)*1.5)
ylab3b <- exp(log(YMAX)+log(YMAX)*1.3)

# 4.
ADJ <- 0.01

datasub$RR_1[datasub$RR_1<=YMIN] <- YMIN+YMIN*ADJ
datasub$RR_2[datasub$RR_2>=YMAX] <- YMAX-YMAX*ADJ

datasub$RR_1_s[datasub$RR_1_s<=YMIN] <- YMIN+YMIN*ADJ
datasub$RR_2_s[datasub$RR_2_s>=YMAX] <- YMAX-YMAX*ADJ

datasub$Estimate[datasub$Estimate<=log(YMIN)] <- log(YMIN)+log(YMIN)*ADJ
datasub$Estimate[datasub$Estimate>=log(YMAX)] <- log(YMAX)-log(YMAX)*ADJ


#### X-axis ####

# IMPORTANT the x-axis is defined by the number of metabolic biomarkers. This number is currently 139 derived from id_name_s. 
# All the labels are mapped around this number, and in this especific order. 
# If the user decides a different array of biomarkers is needed (i.e. only include lipids, or by lipid types instead of by lipoprotein sizes), 
# then this change can only currently be implemented in SAS and the mapping for labels should also be changed manually.

XLIM <- c(min(as.numeric(datasub$id_name_s)), max(as.numeric(datasub$id_name_s)))

#### Labels ####

# labs1 Contains the lipoprotein subclass size acronyms. This is repeated 7 times, once per each measurement of interest (i.e. lipoprotein particle number, cholesterol, free cholesterol, esterified cholesterol, triglycerides, phospholipids, and total lipids).
# labs4 Vector with additional labels for the rest of biomarkers besides lipids within lipoproteins.
# CEX states a vector to use for sizing. If user changes CEX (with upper case), then all those functions using CEX will be proportionally re-sized.
# NOTE if the user changes the array defining id_name_s, then this section should be changed accordingly.

labs1 <- c(rep (c("XXL", "XL", "L", "M", "S", "XS", "IDL", "L", "M", "S", "XL", "L", "M", "S"), 7))

labs4 <- c("VLDL-D", "LDL-D", "HDL-D", "Apo-AI", "Apo-B", "Apo-B/Apo-AI",
           "PUFA", "MUFA", "SFA", "DHA", "LA", "FAw3", "FAw6", "TotFA",
           "PUFA/FA", "MUFA/FA", "SFA/FA", "DHA/FA", "LA/FA", "FAw3/FA", "FAw6/FA",
           "Total Cholines", "P-Cholines", "Sphingomyelins", "P-Gylcerides", 
           "Lactate", "Citrate", "Glucose",
           "Alanine", "Glutamine", "Histidine", "Glycine", "Isoleucine", "Leucine", "Valine", "PA", "Tyrosine",
           "Acetate", "Acetoacetate", "3-HB", "Acetone" , "Pyruvate" ,
           "Albumin", "Creatinine", "GlycA")

CEX <- (13)

#### Graphic device ####
# We decided to use the png graphic device, but others such as pdf or tiff do the trick as well.
# 1. The line we would use produces a filename that includes the file.out substring defined above as well as GROUP and the date.
# 2. For this document, we have named the output file "foo.png".
setwd(project_path)


# 1.
png(paste(project_path, file.out, date, ".png", sep=""), height=6000,width=6000, bg = "white")
# 2.
svg(paste(project_path, file.out, date, ".svg", sep=""), width = 100, height = 100)


 #png(filename = "test2.png", height=6000, width=6000, bg = "white")




#### Margins ####
# The outer margins OMA are quite large (53 spaces, in the 4 margins), as we need space to place our labels.

par(xpd = NA, oma = rep(70,4))






#####################################################  Circos function ###########################################################

# This represents the core of the script, although most of the job is done above. It uses the circlize package but, as you will see, most of the basic R plot functions are preserved and only slightly changed.

# Importantly, this plot uses only very limitedly the applications of the circlize package. Some of the approaches I have had to make the plot are probably clumsy or redundant.

# I highly recommend to have a quick look into the documentation (https://jokergoo.github.io/circlize_book/book/). It is simpler than it looks and relatively easy to work with.


##### Parameters #####

# Circlize transforms a “Cartesian plane” with x and y axis into a circle of y radius and x circumference. 
# Basically, a traditional rectangular plot is twisted into a donut. The donut is called sector. Sectors can be split in several tracks. 
# You can add additional sectors or donuts in ever more central levels.

# Our example only has 1 sector with 1 track.
# track.height determines the proportion of the radius of the circle the track (where we are going to plot) is going to use. 
# The circle used by circlize always has a radius of 1, so a height of 0.1 means 10% of the circle radius.
# gap.degree determines the space between the end of the track and the start of the track.
# start.degree determines the place to start the track at in degrees (count starts at the West).

circos.par("track.height" = 0.6, 
           cell.padding = c(0, 0, 0, 0),
           gap.degree = 45,
           start.degree = 90,
           unit.circle.segments=50000,
           points.overflow.warning=FALSE)

##### Initialize the circle #####

# circos.initialize is the core function that determines the basic parameters. I am still not entirely sure how it works. 
# However, a character object in the factors option (in this example fact) does the trick and this becomes the name of our sector.
# xlim is defined by the length of the id_name_s column, as noted above.

# 1.
circos.initialize(factors = fact, xlim = c(0,len.data))

# 2.
circos.track(factors = fact, ylim = YLIM, bg.border = NA)

##### Draw shades for metabolic subgroups ##### ############################ Eventually to be changed due to addition of 4 markers

# To highlight specific regions use circlize() to calculate the positions in the polar coordinate. Always keep in mind that x-axis in the cell are always clock wise.
# The highlight region to be calculated by circlize()needs coordinates in x and y, a sector.index (in this case "mets"), and a track.index (in this case 1).
# NOTE: In this example, the coordinates were imputed manually and correspond to the array defined by id_names_s. If changed, this section must also be changed to preserve meaningful highlight regions.
# Unless the user wants to change the order of the biomarkers, this section needs no further details explained.

pos1 = circlize(c(0.5, 6.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos1[1, "theta"], pos1[2, "theta"], pos1[1, "rou"], pos1[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos2 = circlize(c(10.5, 14.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos2[1, "theta"], pos2[2, "theta"], pos2[1, "rou"], pos2[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos3 = circlize(c(20.5, 24.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos3[1, "theta"], pos3[2, "theta"], pos3[1, "rou"], pos3[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos4 = circlize(c(28.5, 34.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos4[1, "theta"], pos4[2, "theta"], pos4[1, "rou"], pos4[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos5 = circlize(c(38.5, 42.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos5[1, "theta"], pos5[2, "theta"], pos5[1, "rou"], pos5[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos6 = circlize(c(48.5, 52.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos6[1, "theta"], pos6[2, "theta"], pos6[1, "rou"], pos6[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos7 = circlize(c(56.5, 62.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos7[1, "theta"], pos7[2, "theta"], pos7[1, "rou"], pos7[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos8 = circlize(c(66.5, 70.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos8[1, "theta"], pos8[2, "theta"], pos8[1, "rou"], pos8[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos9 = circlize(c(76.5, 80.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos9[1, "theta"], pos9[2, "theta"], pos9[1, "rou"], pos9[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos10 = circlize(c(84.5, 90.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos10[1, "theta"], pos10[2, "theta"], pos10[1, "rou"], pos10[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos11 = circlize(c(94.5, 98.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos11[1, "theta"], pos11[2, "theta"], pos11[1, "rou"], pos11[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos12 = circlize(c(104.5, 112.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos12[1, "theta"], pos12[2, "theta"], pos12[1, "rou"], pos12[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos13 = circlize(c(119.5, 122.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos13[1, "theta"], pos13[2, "theta"], pos13[1, "rou"], pos13[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos14 = circlize(c(125.5, 133.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos14[1, "theta"], pos14[2, "theta"], pos14[1, "rou"], pos14[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 

pos15 = circlize(c(136.5, 139.5), c(min(YLIM), max(YLIM)), sector.index = "mets", track.index = 1)
draw.sector(pos15[1, "theta"], pos15[2, "theta"], pos15[1, "rou"], pos15[2, "rou"], clock.wise = TRUE, col = "#CCCCCC56", border = NA) 


##### Plotting region #####

# 1. Using circos.track, we select track 1, using factors defined in object fact, and the YLIM defined above.
# 2. We use circos.segmets exactly as segments would be used to create:
  # I. Start and end of plot lines.
  # II. Outer and inner lines.
  # III.Lines at null hypothesis and other cuts.

# 1.
circos.track(track.index = 1, bg.border = "white", factors = fact, ylim = YLIM, panel.fun = function(x,y){
  
  # i)
  # Start 
  circos.segments(x0=min(XLIM)-0.5, y0=max(YLIM), x1=min(XLIM)-0.5, y1=min(YLIM), col = "black", lwd=2)
  # End 
  circos.segments(x0=max(XLIM)+0.5, y0=max(YLIM), x1=max(XLIM)+0.5, y1=min(YLIM), col = "black", lwd=2)
  
  # ii)
  # Outer
  circos.segments(x0=min(XLIM)-.75, y0=max(YLIM), x1=max(XLIM)+0.5, y1=max(YLIM), col = "black", lwd=2)
  # Inner
  circos.segments(x0=min(XLIM)-.75, y0=min(YLIM), x1=max(XLIM)+0.5, y1=min(YLIM), col = "black", lwd=2)
  
  # iii)
  # Lines at YCUTS
  # Null Hypothesis
  circos.segments(x0=min(XLIM)-.75, y0=0, x1=max(XLIM)+0.5, y1=0, col = "black", lwd=2)
  circos.segments(x0=min(XLIM)-.75, y0=(YCUTS[2]), x1=max(XLIM)+0.5, y1=(YCUTS[2]), col = "gray75", lwd=2)
  circos.segments(x0=min(XLIM)-.75, y0=(YCUTS[4]), x1=max(XLIM)+0.5, y1=(YCUTS[4]), col = "gray75", lwd=2)
  
  
  
  
#### Draw bars with estimates ####
  
  # circos.rect draws a rectangle of xleft, xright, ytop, and ybottom dimentions.
  
  # Each bar is defined in the x axis by its position withing is_name_s. Width is defined by simply substracting or adding 0.35 to the coordinates in xleft and xright, respectively.
  
  # Each bar of the 4 types of bars are defined in the y axis by the value in one of the four RR vectors created above, based on the following:
    
    # 1. Positive and “significant”, in dark red (i.e. RR_2_s).
    # 2. Positive and not “significant”, in light red (i.e. RR_2).
    # 3. Negative and “significant”, in dark blue (i.e. RR_1_s).
    # 4. Negative and “non-significant”, in light blue (i.e. RR_1).
  
  # Colours are defined in hex with the last 2 digits defining transparency.

  # Bars
  # 1.
  circos.rect(xleft=(as.numeric(datasub$id_name_s)-.35), xright=(as.numeric(datasub$id_name_s)+.35), ytop=log(as.numeric(datasub$RR_2_s)), ybottom = log(1), col = "#CC0000CC" , lwd=2)
  # 2.
  circos.rect(xleft=(as.numeric(datasub$id_name_s)-.35), xright=(as.numeric(datasub$id_name_s)+.35), ytop=log(as.numeric(datasub$RR_2)), ybottom = log(1), col = "#CC000040" , lwd=2)
  # 3.
  circos.rect(xleft=(as.numeric(datasub$id_name_s)-.35), xright=(as.numeric(datasub$id_name_s)+.35),ytop=log(as.numeric(datasub$RR_1_s)), ybottom = log(1), col = "#0066CCCC" , lwd=2)
  # 4.
  circos.rect(xleft=(as.numeric(datasub$id_name_s)-.35), xright=(as.numeric(datasub$id_name_s)+.35), ytop=log(as.numeric(datasub$RR_1)), ybottom = log(1), col = "#0066CC40" , lwd=2)

  
  
  
#### Draw confidence intervals ####
  
  # Also using circos.rect draw confidence intervals out of StdErr.
  
  # NOTE: This chunk must be plotted after the bars, so the graphic device can draw the confidence intervals on top.
  
  
  # Confidence intervals
  circos.rect(xleft=(as.numeric(datasub$id_name_s)), xright=(as.numeric(datasub$id_name_s)), ytop=(as.numeric(datasub$Estimate)+(1.95*as.numeric(datasub$StdErr))), ybottom = (as.numeric(datasub$Estimate)-(1.95*(as.numeric(datasub$StdErr)))), col = "#262626" , lwd=2)
  
  # Another useful option is circos.points, which allows to draw blobs with the basic R pch options.
  

  
  
#### Display significance stars ####
  circos.points(x=as.numeric(datasub$id_name_s[datasub$Sig == 1]), y=log(ylab0), pch = 42, col = "#000000", cex = CEX*1.0)
  #circos.text(x=as.numeric(datasub$id_name_s[datasub$Sig == 1]), y=log(ylab0), niceFacing = TRUE, labels = "*", cex = CEX*0.9, adj=0, font=2)
  
  #### Draw y-axis ####
  # Similar to basic R plotting axis options.
  
  circos.yaxis(at=YCUTS, labels = YCUTS.LABS, labels.cex = CEX*1, tick = FALSE, col = "white")
  
#### Draw labels ####
  # We use the function circos.text to paste the labels at the margins of the plot (remember we left a lot of space at the margins when defining the plot par above).
  
  # The option facing defines how to paste the labels. The package has several options that make text look nicely, including niceFacing, which makes text flip so it can be read easily.
  
  # The positions for labels are, unfortunately, very inefficiently defined manually.
  
  # All the .shift objects were used to manually adjust the labels. These work now, but maybe play with them to see how the labels move.
  
  
  VLDL.shift <- 2 
  LDL.shift <- 1.5
  HDL.shift <- 1.5
  
  ylab3_size <- 0.9
  ylab2_size <- 0.9
  ylab1_size <- 0.8
  
  circos.text(x=0.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Lipoprotein particles", cex = CEX* ylab3_size, adj=0, font=2)
  circos.text(x=0.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=6.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=10.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=14.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Cholesterol", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=14.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=20.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=24.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=28.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Free cholesterol", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=28.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=34.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=38.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = FALSE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=42.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Esterified Cholesterol", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=42.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=48.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=52.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=56.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Triglycerides", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=56.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=62.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=66.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=70.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Phospholipids", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=70.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=76.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=80.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=84.5+5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Total lipids", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=84.5+VLDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "VLDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=90.5+LDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "LDL", cex = CEX*0.8, adj=0, font=2)
  circos.text(x=94.5+HDL.shift, y=log(ylab2), facing = "bending.inside", niceFacing = TRUE, labels = "HDL", cex = CEX*0.8, adj=0, font=2) 
  
  circos.text(x=98.5, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Sizes & Apo-LP", cex = CEX*ylab3_size, adj=0, font=2)
  
  circos.text(x=104.5+6, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "Fatty acids", cex = CEX*ylab3_size, adj=0, font=2)
  
  circos.text(x=119.5, y=log(ylab3), facing = "bending.inside", niceFacing = FALSE, labels = "Cholines, glycolysis & AA", cex = CEX*ylab3_size, adj=0, font=2)
  
  circos.text(x=136, y=log(ylab3), facing = "bending.inside", niceFacing = TRUE, labels = "  Ketone bodies", cex = CEX*ylab3_size, adj=0, font=2)
  circos.text(x=136, y=log(ylab3b), facing = "bending.inside", niceFacing = TRUE, labels = "& fluid balance", cex = CEX*ylab3_size, adj=0, font=2)
  
  #Inner Labels
  circos.text(x=c(1:98)+0.25,   y = log(ylab1), labels = labs1, facing = "clockwise", niceFacing = TRUE, cex = CEX*ylab1_size, adj = 0, font = 1)
  circos.text(x=c(99:143)+0.25, y = log(ylab1), labels = labs4, facing = "clockwise", niceFacing = TRUE, cex = CEX*ylab1_size, adj = 0, font = 1)
  
  
}

)


#### Title ####
  # Paste the title at the centre of the circle (at x=0, y=0).

  # Use circos.clear to reset the circular layout parameters.

  # Close the plotting device with dev.off().



if (length(control) ==1){
  text(0, 0, paste(control, "\n±\n", DOI, sep=""), cex = CEX*1.1, font=2)
} else{
  text(0, 0, paste("BTD \n CLD \ Cholelithiasis", "\n±\n", DOI, sep=""), cex = CEX*1.1, font=2)
}
dev.off()
circos.clear()  


# "CLD + BTD +\n Cholelithiasis \n±\n"


############################################################### 6. Output ###################################################

#png()

## 2
```

